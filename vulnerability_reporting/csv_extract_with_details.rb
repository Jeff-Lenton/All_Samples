# kenna-bulk-custom-field-update
require 'rest-client'
require 'json'
require 'csv'

#These are the arguments we are expecting to get 
@token = ARGV[0]
@assets_per_query = ARGV[1] #number of assets to update at one time to keep the vuln pull under 20 pages
@report_filename = ARGV[2] #name of the resulting csv file

#Variables we'll need later
@vuln_url = 'https://api.kennasecurity.com/vulnerabilities/search'
@asset_url = 'https://api.kennasecurity.com/assets/search'
@headers = {'Content-type' => 'application/json', 'X-Risk-Token' => @token }

@max_retries = 5

start_time = Time.now
@output_filename = Logger.new("cvs-extract-#{start_time.strftime("%Y%m%dT%H%M")}.txt")
@debug = false



# Encoding characters
enc_colon = "%3A"
enc_dblquote = "%22"
enc_space = "%20"
csv_headers = 
  [
    "id",
    "status",
    "cve id",
    "score",
    "cve description",
    #"cve published",
    "created",
    "last seen",
    "QIDs",
    "fix id",
    "cvss threat",
    "cvss severity",
    "active breach",
    "malware exploitable",
    "easily exploitable",
    "predicted exploitable",
    "patch available",
    "patch published",
    "hostname",
    "ip",
    "os",
    "tags",
    "details"
  ]


def get_data(get_url)
  puts "starting query" if @debug
  puts "get data url = #{get_url}" if @debug
  query_return = ""
   begin
      query_return = RestClient::Request.execute(
        method: :get,
        url: get_url,
        headers: @headers
      )
      rescue RestClient::TooManyRequests =>e
        retry
      rescue RestClient::UnprocessableEntity => e
        puts "unprocessible entity: #{e.message}"
      rescue RestClient::BadRequest => e
        @output_filename.error("Rest client BadRequest: #{get_url}...#{e.message} (time: #{Time.now.to_s}, start time: #{@start_time.to_s})")
        log_output.close
        puts "BadRequest: #{e.backtrace.inspect}"
      rescue RestClient::Exception => e
        @retries ||= 0
        if @retries < @max_retries
          @retries += 1
          sleep(15)
          retry
        else
          @output_filename.error("General RestClient error #{get_url}... #{e.message}(time: #{Time.now.to_s}, start time: #{@start_time.to_s})")
          puts "Unable to get vulns: #{e.backtrace.inspect}"
        end
      rescue Exception => e
        @output_filename.error("General Exception: #{get_url}...#{e.message} (time: #{Time.now.to_s}, start time: #{@start_time.to_s})")
        puts "BadRequest: #{e.backtrace.inspect}"
    end
  return query_return
end
CSV.open(@report_filename , 'w') do |csv|
  csv << csv_headers
  csv.close
end
pages = 0
page = 1
page_json = ''
assetQuery = "#{@asset_url}?status%5B%5D=active"
asset_json = JSON.parse(get_data(assetQuery))
if !asset_json.nil? then
  pages = asset_json["meta"].fetch("pages")
  while page < pages+1 do 
    asset_array = []
    puts "pages = #{pages} and page = #{page}" if @debug
    if page ==1 then
      page_json = asset_json["assets"]
    else 
      asset_json = JSON.parse(get_data("#{assetQuery}&page=#{page}"))
      page_json = asset_json["assets"]
    end
    page_json.each do |asset| 
      asset_array << Array[asset.fetch("id"),asset.fetch("hostname"),asset.fetch("ip_address"),asset.fetch("operating_system"),asset.fetch("tags").join(',')]
    end
    asset_array.each_slice(@assets_per_query.to_i) do |all_assets|
      id_array =[]
      all_assets.each do |one|
        id_array << one[0]
      end
      asset_string = id_array.join('&asset%5Bid%5D%5B%5D=')
      vuln_query = "#{@vuln_url}?asset%5Bid%5D%5B%5D=#{asset_string}&include_details=true"
      vuln_pages = 0
      vuln_page = 1
      CSV.open(@report_filename , 'a') do |csv|
        #csv << csv_headers
        vuln_json = JSON.parse(get_data(vuln_query))
        if !vuln_json.nil? then
          vuln_pages = vuln_json["meta"].fetch("pages")
          if vuln_pages > 20 then
            puts "TOO MANY VULNS RERUN WITH A LOWER ASSET COUNT PER BLOCK"
            abort
          end
          vuln_array = []
          while vuln_page < vuln_pages+1 do 
            puts "vuln pages = #{vuln_pages} and vuln page = #{vuln_page}" if @debug
            if vuln_page ==1 then
              vuln_page_json = vuln_json["vulnerabilities"]
            else 
              vuln_json = JSON.parse(get_data("#{vuln_query}&page=#{vuln_page}"))
              vuln_page_json = vuln_json["vulnerabilities"]
            end
            vuln_page_json.each do |vuln| 
              vuln_id = nil
              status = nil
              cve_id = nil
              score = nil
              cve_description = nil
              cve_published = nil
              created = nil
              last_seen = nil
              qids = []
              fix_id = nil
              cvss_threat = nil
              cvss_severity = nil
              active_breach = nil
              malware_exploitable = nil
              easily_exploitable = nil
              predicted_exploitable = nil
              patch_available = nil
              patch_published = nil
              hostname = nil
              ip = nil
              os = nil
              tags = nil
              details = nil

              vuln_id = vuln.fetch("id")
              status = vuln.fetch("status")
              cve_id = vuln.fetch("cve_id")
              score = vuln.fetch("risk_meter_score")
              cve_description = vuln.fetch("cve_description")
              #cve_published = vuln.fetch("id")
              created = vuln.fetch("created_at")
              last_seen = vuln.fetch("last_seen_time")
              qids = vuln.fetch("identifiers")
              fix_id = vuln.fetch("fix_id")
              cvss_threat = vuln.fetch("threat")
              cvss_severity = vuln.fetch("severity")
              active_breach = vuln.fetch("active_internet_breach")
              malware_exploitable = vuln.fetch("malware_exploitable")
              easily_exploitable = vuln.fetch("easily_exploitable")
              predicted_exploitable = vuln.fetch("predicted_exploitable")
              patch_published = vuln.fetch("patch_published_at")
              if !patch_published.nil? && !patch_published.empty? then
                patch_available = "true"
              else
                patch_available = "false"
              end
              asset_id = vuln.fetch("asset_id")
              a = []
              a = all_assets.find{|a| a[0] == asset_id}
              hostname = a[1]
              ip = a[2]
              os = a[3]
              tags = a[4]
              details = vuln["scanner_vulnerabilities"].first.fetch("details") unless vuln["scanner_vulnerabilities"].first.nil?

              csv << [vuln_id,
                status,
                cve_id,
                score,
                cve_description,
                created,
                last_seen,
                qids.join(', '),
                fix_id,
                cvss_threat,
                cvss_severity,
                active_breach,
                malware_exploitable,
                easily_exploitable,
                predicted_exploitable,
                patch_available,
                patch_published,
                hostname,
                ip,
                os,
                tags,
                details]

              end
              vuln_page += 1
            end
          end
        end
      end
      page += 1 
  end
end


